//! CCH weights format - customized edge weights for CCH
//!
//! Stores per-mode edge weights for both UP and DOWN edges.
//! Generated by Step 8 (customization).

use anyhow::Result;
use std::fs::File;
use std::io::{BufReader, Read};
use std::path::Path;

const MAGIC: u32 = 0x43434857; // "CCHW"

/// CCH weights - stores weights for UP and DOWN edges
#[derive(Debug, Clone)]
pub struct CchWeights {
    pub up: Vec<u32>,
    pub down: Vec<u32>,
}

pub struct CchWeightsFile;

impl CchWeightsFile {
    pub fn read<P: AsRef<Path>>(path: P) -> Result<CchWeights> {
        let mut reader = BufReader::new(File::open(path)?);

        // Read header (32 bytes)
        // magic(4) + reserved(4) + n_up(8) + n_down(8) + reserved(8) = 32
        let mut header = [0u8; 32];
        reader.read_exact(&mut header)?;

        let magic = u32::from_le_bytes([header[0], header[1], header[2], header[3]]);
        if magic != MAGIC {
            anyhow::bail!(
                "Invalid magic: expected 0x{:08X}, got 0x{:08X}",
                MAGIC,
                magic
            );
        }

        let n_up = u64::from_le_bytes([
            header[8], header[9], header[10], header[11], header[12], header[13], header[14],
            header[15],
        ]) as usize;
        let n_down = u64::from_le_bytes([
            header[16], header[17], header[18], header[19], header[20], header[21], header[22],
            header[23],
        ]) as usize;

        // Read up weights
        let mut up = Vec::with_capacity(n_up);
        for _ in 0..n_up {
            let mut buf = [0u8; 4];
            reader.read_exact(&mut buf)?;
            up.push(u32::from_le_bytes(buf));
        }

        // Read down weights
        let mut down = Vec::with_capacity(n_down);
        for _ in 0..n_down {
            let mut buf = [0u8; 4];
            reader.read_exact(&mut buf)?;
            down.push(u32::from_le_bytes(buf));
        }

        Ok(CchWeights { up, down })
    }
}
